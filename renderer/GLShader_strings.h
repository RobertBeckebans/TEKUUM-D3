/* OpenGL GLSL shaders, as static data buffers for release mode builds */
/* DO NOT EDIT - this file is autogenerated - see BUILD.txt */
/* To regenerate this file, run: premake4 embed */ 

typedef struct {
	char *name;
	char *shaderText;
} glslShaderDef_t;

static const glslShaderDef_t glsl_shaders[] = {
{ "geometricFill_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nattribute vec4		va_TexCoord0;\nattribute vec3		va_Tangent;\nattribute vec3		va_Bitangent;\nattribute vec3		va_Normal;\nuniform mat4		u_ModelMatrix;\nuniform mat4		u_ShadowMatrix;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform vec4		u_BumpMatrixS;\nuniform vec4		u_BumpMatrixT;\nuniform vec4		u_SpecularMatrixS;\nuniform vec4		u_SpecularMatrixT;\nuniform vec4		u_ColorModulate;\nuniform vec4		u_Color;\nvarying vec4		var_Position;\nvarying vec2		var_TexDiffuse;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_TexNormal;\n#if !defined(r_DeferredLighting)\nvarying vec2		var_TexSpecular;\n#endif\nvarying vec3		var_Tangent;\nvarying vec3		var_Bitangent;\n#endif\nvarying vec3		var_Normal;\nvarying vec4		var_Color;\nvoid	main()\n{\n	vec4 position;\n	vec3 tangent;\n	vec3 bitangent;\n	vec3 normal;\n#if defined(USE_VERTEX_SKINNING)\n	\n	#if defined(USE_NORMAL_MAPPING)\n	VertexSkinning_P_TBN(	va_Position, va_Tangent, va_Bitangen"
	"t, va_Normal,\n							position, tangent, bitangent, normal);\n	#else\n	VertexSkinning_P_N(	va_Position, va_Normal,\n						position, normal);\n	#endif\n#elif defined(USE_VERTEX_ANIMATION)\n	\n	#if defined(USE_NORMAL_MAPPING)\n	VertexAnimation_P_TBN(	va_Position, va_Position2,\n							va_Tangent, va_Tangent2,\n							va_Bitangent, va_Bitangent2,\n							va_Normal, va_Normal2,\n							u_VertexInterpolation,\n							position, tangent, bitangent, normal);\n	#else\n	VertexAnimation_P_N(va_Position, va_Position2,\n						va_Normal, va_Normal2,\n						u_VertexInterpolation,\n						position, normal);\n	#endif\n	\n#else\n	position = gl_Position;\n		\n	#if defined(USE_NORMAL_MAPPING)\n	tangent = va_Tangent;\n	bitangent = va_Bitangent;\n	#endif\n	\n	normal = va_Normal;\n#endif\n	// transform vertex position into homogenous clip-space\n	// gl_Position = gl_ModelViewProjectionMatrix * position;\n	gl_Position = ftransform();\n	\n	// transform position into world space\n	var_Position = (u_ModelMatrix * position).xyzw;\n#if def"
	"ined(USE_NORMAL_MAPPING)\n	var_Tangent.xyz = (u_ModelMatrix * vec4(tangent, 0.0)).xyz;\n	var_Bitangent.xyz = (u_ModelMatrix * vec4(bitangent, 0.0)).xyz;\n#endif\n	\n	var_Normal.xyz = (u_ModelMatrix * vec4(normal, 0.0)).xyz;\n		\n	// diffuse map texgen\n	var_TexDiffuse.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_TexDiffuse.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n	\n#if defined(USE_NORMAL_MAPPING)\n	// normal map texgen\n#if 0\n	var_TexNormal.s = dot(u_BumpMatrixS, va_TexCoord0);\n	var_TexNormal.t = dot(u_BumpMatrixT, va_TexCoord0);\n#else\n	var_TexNormal.st = va_TexCoord0.st;\n#endif\n	\n#if !defined(r_DeferredLighting)\n	// specular map texgen\n	var_TexSpecular.s = dot(u_SpecularMatrixS, va_TexCoord0);\n	var_TexSpecular.t = dot(u_SpecularMatrixT, va_TexCoord0);\n#endif\n#endif\n	\n	// assign color\n	var_Color = gl_Color * u_ColorModulate + u_Color;\n}\n"},

{ "geometricFill_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\n#extension GL_ARB_draw_buffers : enable\nuniform sampler2D	u_DiffuseImage;\nuniform sampler2D	u_NormalMap;\nuniform sampler2D	u_SpecularMap;\nuniform samplerCube	u_EnvironmentMap0;\nuniform samplerCube	u_EnvironmentMap1;\nuniform float		u_EnvironmentInterpolation;\n// uniform int		u_AlphaTest;\nuniform vec3		u_GlobalViewOrigin;\nuniform vec3        u_AmbientColor;\nuniform float		u_DepthScale;\nuniform mat4		u_ModelMatrix;\n// uniform vec4		u_PortalPlane;\nvarying vec4		var_Position;\nvarying vec2		var_TexDiffuse;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_TexNormal;\n#if !defined(r_DeferredLighting)\nvarying vec2		var_TexSpecular;\n#endif\nvarying vec3		var_Tangent;\nvarying vec3		var_Bitangent;\n#endif\nvarying vec3		var_Normal;\nvarying vec4		var_Color;\nvoid	main()\n{\n#if defined(USE_PORTAL_CLIPPING)\n	{\n		float dist = dot(var_Position.xyz, u_PortalPlane.xyz) - u_PortalPlane.w;\n		if(dist < 0.0)\n		{\n			discard;\n			return;\n		}"
	"\n	}\n#endif\n	// compute view direction in world space\n	vec3 V = normalize(u_GlobalViewOrigin - var_Position.xyz);\n	vec2 texDiffuse = var_TexDiffuse.st;\n#if defined(USE_NORMAL_MAPPING)\n	// invert tangent space for two sided surfaces\n	mat3 tangentToWorldMatrix;\n	\n#if defined(TWOSIDED)\n	if(gl_FrontFacing)\n	{\n		tangentToWorldMatrix = mat3(-var_Tangent.xyz, -var_Bitangent.xyz, -var_Normal.xyz);\n	}\n	else\n#endif\n	{\n		tangentToWorldMatrix = mat3(var_Tangent.xyz, var_Bitangent.xyz, var_Normal.xyz);\n	}\n	\n	vec2 texNormal = var_TexNormal.st;\n#if !defined(r_DeferredLighting)\n	vec2 texSpecular = var_TexSpecular.st;\n#endif\n#if defined(USE_PARALLAX_MAPPING)\n	\n	// ray intersect in view direction\n	\n	mat3 worldToTangentMatrix;\n	#if defined(GLHW_ATI) || defined(GLHW_ATI_DX10) || defined(GLDRV_MESA)\n	worldToTangentMatrix = mat3(tangentToWorldMatrix[0][0], tangentToWorldMatrix[1][0], tangentToWorldMatrix[2][0],\n								tangentToWorldMatrix[0][1], tangentToWorldMatrix[1][1], tangentToWorldMatrix[2][1],"
	" \n								tangentToWorldMatrix[0][2], tangentToWorldMatrix[1][2], tangentToWorldMatrix[2][2]);\n	#else\n	worldToTangentMatrix = transpose(tangentToWorldMatrix);\n	#endif\n	// compute view direction in tangent space\n	vec3 Vts = worldToTangentMatrix * (u_GlobalViewOrigin - var_Position.xyz);\n	Vts = normalize(Vts);\n	\n	// size and start position of search in texture space\n	vec2 S = Vts.xy * -u_DepthScale / Vts.z;\n		\n#if 0\n	vec2 texOffset = vec2(0.0);\n	for(int i = 0; i < 4; i++) {\n		vec4 Normal = texture2D(u_NormalMap, texNormal.st + texOffset);\n		float height = Normal.a * 0.2 - 0.0125;\n		texOffset += height * Normal.z * S;\n	}\n#else\n	float depth = RayIntersectDisplaceMap(texNormal, S, u_NormalMap);\n	\n	// compute texcoords offset\n	vec2 texOffset = S * depth;\n#endif\n	\n	texNormal.st += texOffset;\n	\n#if !defined(r_DeferredLighting)\n	texDiffuse.st += texOffset;\n	texSpecular.st += texOffset;\n#endif\n	\n#endif // USE_PARALLAX_MAPPING\n	// compute normal in world space from normalmap\n	vec3 N = t"
	"angentToWorldMatrix * (2.0 * (texture2D(u_NormalMap, texNormal).xyz - 0.5));\n	\n#if 0\n	gl_FragColor = texture2D(u_NormalMap, texNormal);\n	return;\n#endif\n	\n#if !defined(r_DeferredLighting)\n	\n	// compute the specular term\n#if defined(USE_REFLECTIVE_SPECULAR)\n	vec3 specular = texture2D(u_SpecularMap, texSpecular).rgb;\n	vec4 envColor0 = textureCube(u_EnvironmentMap0, reflect(-V, N)).rgba;\n	vec4 envColor1 = textureCube(u_EnvironmentMap1, reflect(-V, N)).rgba;\n	\n	specular *= mix(envColor0, envColor1, u_EnvironmentInterpolation).rgb;\n	\n#if 0\n	// specular = vec4(u_EnvironmentInterpolation, u_EnvironmentInterpolation, u_EnvironmentInterpolation, 1.0);\n	specular = envColor0;\n#endif\n#else\n	vec3 specular = texture2D(u_SpecularMap, texSpecular).rgb;\n#endif // USE_REFLECTIVE_SPECULAR\n#endif // #if !defined(r_DeferredLighting)\n#else // USE_NORMAL_MAPPING\n	\n	vec3 N;\n#if defined(TWOSIDED)\n	if(gl_FrontFacing)\n	{\n		N = -normalize(var_Normal);\n		// gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		// retu"
	"rn;\n	}\n	else\n#endif\n	{\n		N = normalize(var_Normal);\n	}\n		\n	vec3 specular = vec3(0.0);\n	\n#endif // USE_NORMAL_MAPPING\n	// compute the diffuse term\n	vec4 diffuse = texture2D(u_DiffuseImage, texDiffuse);\n	\n#if 0\n	gl_FragColor = diffuse;\n	return;\n#endif\n	\n#if defined(USE_ALPHA_TESTING)\n	if(u_AlphaTest == ATEST_GT_0 && diffuse.a <= 0.0)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_LT_128 && diffuse.a >= 0.5)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_GE_128 && diffuse.a < 0.5)\n	{\n		discard;\n		return;\n	}\n#endif\n	\n//	vec4 depthColor = diffuse;\n//	depthColor.rgb *= u_AmbientColor;\n	\n	// convert normal back to [0,1] color space\n	N = N * 0.5 + 0.5;\n#if defined(r_DeferredLighting)\n	gl_FragColor = vec4(N, 0.0);\n#else\n	gl_FragData[0] = vec4(0.0, 0.0, 0.0, 1.0);\n	gl_FragData[1] = vec4(diffuse.rgb, var_Color.a);\n	gl_FragData[2] = vec4(N, var_Color.a);\n	gl_FragData[3] = vec4(specular, var_Color.a);\n#endif // r_DeferredLighting\n}\n"},

{ "forwardLighting_vs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\nattribute vec4		va_TexCoord0;\nattribute vec3		va_Tangent;\nattribute vec3		va_Bitangent;\nattribute vec3		va_Normal;\n// attribute vec4		va_Color;\nuniform vec3		u_LocalLightOrigin;\nuniform vec3		u_LocalViewOrigin;\nuniform vec4		u_LightProjectS;\nuniform vec4		u_LightProjectT;\nuniform vec4		u_LightProjectQ;\nuniform vec4		u_LightFalloffS;\nuniform mat4		u_ModelMatrix;\nuniform mat4		u_ShadowMatrix;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform vec4		u_BumpMatrixS;\nuniform vec4		u_BumpMatrixT;\nuniform vec4		u_SpecularMatrixS;\nuniform vec4		u_SpecularMatrixT;\nuniform vec4		u_ColorModulate;\nuniform vec4		u_Color;\n/*\n#if defined(AMBIENT_ONLY)\nuniform vec3		u_ModelMatrix0		: ENV20,\nuniform vec3		modelMatrix1		: ENV21,\nuniform vec3		modelMatrix2		: ENV22,\n#endif\n*/\nvarying vec4		var_Position;\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying ve"
	"c2		var_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying vec3		var_LightProjection;\nvarying vec4		var_ShadowProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n	\n	// transform position into world space\n	var_Position = u_ModelMatrix * gl_Vertex;\n	// light falloff texgen\n	var_LightFalloff.x = dot(u_LightFalloffS, gl_Vertex);\n	var_LightFalloff.y = 0.5;\n  \n	// light projection texgen\n	// var_LightProjection = mat4x3(u_LightProjectS, u_LightProjectT, u_LightProjectQ) * gl_Vertex;\n#if 1\n	var_LightProjection.s = dot(u_LightProjectS, gl_Vertex);\n	var_LightProjection.t = dot(u_LightProjectT, gl_Vertex);\n	var_LightProjection.z = dot(u_LightProjectQ, gl_Vertex);\n#else\n	mat4 lightMVP = mat4(	u_LightProjectS.x, u_LightProjectT.x, u_LightFalloffS.x, u_LightProjectQ.x,\n						"
	"	u_LightProjectS.y, u_LightProjectT.y, u_LightFalloffS.y, u_LightProjectQ.y,\n							u_LightProjectS.z, u_LightProjectT.z, u_LightFalloffS.z, u_LightProjectQ.z,\n							u_LightProjectS.w, u_LightProjectT.w, u_LightFalloffS.w, u_LightProjectQ.w);\n							\n	var_LightProjection = (lightMVP * gl_Vertex).xyw;\n#endif\n#if defined(USE_SHADOWING)\n	var_ShadowProjection = u_ShadowMatrix * gl_Vertex;\n#endif\n	// diffuse map texgen\n	var_DiffuseST.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_DiffuseST.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n	// specular map texgen\n	var_SpecularST.s = dot(u_SpecularMatrixS, va_TexCoord0);\n	var_SpecularST.t = dot(u_SpecularMatrixT, va_TexCoord0);\n	// light and halfangle vectors\n	vec3 L = normalize(u_LocalLightOrigin.xyz - gl_Vertex.xyz);\n	vec3 V = normalize(u_LocalViewOrigin.xyz - gl_Vertex.xyz);\n	vec3 H = normalize(L) + normalize(V);\n	\n#if defined(USE_NORMAL_MAPPING)\n	// normal map texgen\n	var_BumpST.s = dot(u_BumpMatrixS, va_TexCoord0);\n	var_BumpST.t = dot(u_BumpMatrixT"
	", va_TexCoord0);\n	// rotate L and H into tangent space\n	\n	// mat3 TBN = mat3(normalize(va_Tangent), normalize(va_Bitangent), normalize(va_Normal));\n#if 0\n	mat3 TBN = transpose(mat3(va_Tangent, va_Bitangent, va_Normal));\n#else\n	mat3 TBN = mat3(va_Tangent.x, va_Bitangent.x, va_Normal.x,\n					va_Tangent.y, va_Bitangent.y, va_Normal.y,\n					va_Tangent.z, va_Bitangent.z, va_Normal.z);\n#endif\n	\n	var_LightVector = TBN * L;\n	var_HalfAngleVector = TBN * H;\n#else\n	// regular blinn-phong lighting can be done in object space\n	var_Normal = va_Normal;\n	var_LightVector = L;\n	var_HalfAngleVector = H;\n#endif\n	// primary color\n	var_PrimaryColor = gl_Color * u_ColorModulate + u_Color;\n}\n"},

{ "forwardLighting_fs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform samplerCube u_NormalCubeMapImage;	// TEXUNIT0\nuniform sampler2D   u_NormalImage; 			// TEXUNIT1\nuniform sampler2D   u_LightFalloffImage;	// TEXUNIT2\nuniform sampler2D   u_LightImage;			// TEXUNIT3\nuniform sampler2D   u_DiffuseImage;			// TEXUNIT4\nuniform sampler2D   u_SpecularImage;		// TEXUNIT5\nuniform sampler2D   u_JitterImage;			// TEXUNIT6\n// #if defined(LIGHT_DIRECTIONAL)\nuniform sampler2D	u_ShadowImage0;\nuniform sampler2D	u_ShadowImage1;\nuniform sampler2D	u_ShadowImage2;\nuniform sampler2D	u_ShadowImage3;\nuniform sampler2D	u_ShadowImage4;\n// #elif defined(LIGHT_PROJ)\n// uniform sampler2D	u_ShadowImage0;\n// #else\nuniform samplerCube	u_ShadowCubeImage;\n// #endif\nuniform mat4		u_ModelMatrix;\nuniform mat4		u_ShadowMatrix;\nuniform float       u_ShadowTexelSize;\nuniform float       u_ShadowBlur;\nuniform vec4		u_PositionToJitterTexScale;\nuniform vec4		u_JitterTexScale;\nuniform vec4		u_JitterTexOffset;\nuniform"
	" vec4		u_DiffuseColor;\nuniform vec4		u_SpecularColor;\nuniform vec3		u_LocalLightOrigin;\nuniform vec3		u_GlobalLightOrigin;\nuniform float       u_LightRadius;\nvarying vec4		var_Position;\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying vec3		var_LightProjection;\nvarying vec4		var_ShadowProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid MakeNormalVectors(const vec3 forward, inout vec3 right, inout vec3 up)\n{\n	right.y = -forward.x;\n	right.z = forward.y;\n	right.x = forward.z;\n	float d = dot(right, forward);\n	right += forward * -d;\n	normalize(right);\n	up = cross(right, forward);\n}\nfloat Rand(vec2 co)\n{\n	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat Noise(vec2 co)\n{\n	return Rand(floor(co * 128.0));\n}\nvec3 RandomVec3(vec2 st)\n{\n	vec3 dir;\n#if "
	"1\n	float r = Rand(st + u_JitterTexOffset.st);\n	float angle = 2.0 * M_PI * r;// / 360.0;\n	\n	dir = normalize(vec3(cos(angle), sin(angle), r));\n#else\n	// dir = texture2D(u_NoiseMap, gl_FragCoord.st * r_FBufScale).rgb;\n	// st *= r_FBufScale.st * ; // * u_JitterTexScale.st + u_JitterTexOffset.st;\n	\n	st *= u_PositionToJitterTexScale.st * u_JitterTexScale.st;\n	st += u_JitterTexOffset.st;\n	// gl_FragColor = vec4(texture2D(u_JitterImage, st).rgb, 1.0);\n	\n	dir = normalize(2.0 * (texture2D(u_JitterImage, st).xyz - 0.5));\n#endif\n	\n	return dir;\n}\n/*\nsource: http://en.wikipedia.org/wiki/Chebyshev%27s_inequality\nX = distribution\nmu = mean\nsigma = standard deviation\n=> then for any real number k > 0:\nPr(X -mu >= k * sigma) <= 1 / ( 1 + k^2)\n*/\n#if defined(VSM) || defined(EVSM)\nfloat ChebyshevUpperBound(vec2 shadowMoments, float vertexDistance, float minVariance)\n{\n	float shadowDistance = shadowMoments.x;\n	float shadowDistanceSquared = shadowMoments.y;\n	// compute variance\n	float E_x2 = shadowDi"
	"stanceSquared;\n	float Ex_2 = shadowDistance * shadowDistance;\n	float variance = max(E_x2 - Ex_2, max(minVariance, VSM_EPSILON));\n	// float variance = smoothstep(minVariance, 1.0, max(E_x2 - Ex_2, 0.0));\n	// compute probabilistic upper bound\n	float d = vertexDistance - shadowDistance;\n	float pMax = variance / (variance + (d * d));\n	\n	/*\n	#if defined(r_LightBleedReduction)\n	pMax = smoothstep(r_LightBleedReduction, 1.0, pMax);\n	#endif\n	*/\n	\n	// one-tailed Chebyshev with k > 0\n	return (vertexDistance <= shadowDistance ? 1.0 : pMax);\n}\n#endif\n#if defined(EVSM)\nvec2 WarpDepth(float depth)\n{\n    // rescale depth into [-1, 1]\n    depth = 2.0 * depth - 1.0;\n    float pos =  exp( r_EVSMExponents.x * depth);\n    float neg = -exp(-r_EVSMExponents.y * depth);\n	\n    return vec2(pos, neg);\n}\nvec4 ShadowDepthToEVSM(float depth)\n{\n	vec2 warpedDepth = WarpDepth(depth);\n	return vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n#endif // #if defined(EVSM)\n#if defined(LIGHT_PROJ)\nvec4 Fetc"
	"hShadowMoments(vec2 st)\n{\n#if defined(EVSM) && defined(r_EVSMPostProcess)\n	return ShadowDepthToEVSM(texture2D(u_ShadowImage0, st).r);\n#else\n	// return texture2DProj(u_ShadowImage0, (u_ShadowMatrix * var_Position.xyzw).xyw);\n	return texture2DProj(u_ShadowImage0, var_LightProjection.xyz);\n	// return texture2DProj(u_ShadowImage0, var_ShadowProjection.xyz);\n	// return texture2D(u_ShadowImage0, st);\n#endif\n}\n#if defined(r_PCFSamples)\nvec4 PCF(vec4 shadowVert, float filterWidth, float samples)\n{\n	vec4 moments = vec4(0.0, 0.0, 0.0, 0.0);\n	\n#if 0\n	// compute step size for iterating through the kernel\n	float stepSize = 2.0 * filterWidth / samples;\n	for(float i = -filterWidth; i < filterWidth; i += stepSize)\n	{\n		for(float j = -filterWidth; j < filterWidth; j += stepSize)\n		{\n			moments += FetchShadowMoments(shadowVert.xy / shadowVert.w + vec2(i, j));\n		}\n	}\n#else\n	for(int i = 0; i < samples; i++)\n	{\n		for(int j = 0; j < samples; j++)\n		{\n			vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufS"
	"cale + vec2(i, j));// * filterWidth;\n			// rand = vec3(0.0, 0.0, 1.0);\n			// rand.z = 0;\n			// rand = normalize(rand);// * filterWidth;\n			\n			moments += FetchShadowMoments(shadowVert.xy / shadowVert.w + rand.xy);\n		}\n	}\n#endif\n	\n	// return average of the samples\n	moments *= (1.0 / (samples * samples));\n	return moments;\n}\n#endif // #if defined(r_PCFSamples)\n#else\nvec4 FetchShadowMoments(vec3 I)\n{\n#if defined(EVSM) && defined(r_EVSMPostProcess)\n	return ShadowDepthToEVSM(textureCube(u_ShadowCubeImage, I).r);\n#else\n	return textureCube(u_ShadowCubeImage, I);\n#endif\n}\n#if defined(r_PCFSamples)\nvec4 PCF(vec3 I, float filterWidth, float samples)\n{\n	vec3 forward, right, up;\n	\n	forward = normalize(I);\n	MakeNormalVectors(forward, right, up);\n	\n	vec4 moments = vec4(0.0, 0.0, 0.0, 0.0);\n	\n#if 0\n	// compute step size for iterating through the kernel\n	float stepSize = 2.0 * filterWidth / samples;\n	for(float i = -filterWidth; i < filterWidth; i += stepSize)\n	{\n		for(float j = -filterWid"
	"th; j < filterWidth; j += stepSize)\n		{\n			moments += FetchShadowMoments(I + right * i + up * j);\n		}\n	}\n#else\n	for(int i = 0; i < samples; i++)\n	{\n		for(int j = 0; j < samples; j++)\n		{\n			// vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufScale + vec2(i, j));// * filterWidth;\n			vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufScale + vec2(i, j));// * u_ShadowTexelSize);\n			// rand.z = 0;\n			// rand = normalize(rand) * filterWidth;\n			\n			moments += FetchShadowMoments(I + right * rand.x + up * rand.y);\n		}\n	}\n#endif\n	\n	// return average of the samples\n	moments *= (1.0 / (samples * samples));\n	return moments;\n}\n#endif // #if defined(r_PCFSamples)\n#endif\nvoid main()\n{\n#if 0\n	// create random noise vector\n	vec3 rand = RandomVec3(gl_FragCoord.st);\n	gl_FragColor = vec4(rand * 0.5 + 0.5, 1.0);\n	// vec2 st = gl_FragCoord.st * u_PositionToJitterTexScale.st;// * u_JitterTexScale.st;\n	// st += u_JitterTexOffset.st;\n	// gl_FragColor = vec4(texture2D(u_JitterImage, st).rgb, 1.0);\n	return;"
	"\n#endif\n	float shadow = 1.0;\n	\n#if defined(USE_SHADOWING)\n#if defined(LIGHT_DIRECTIONAL)\n	vec4 shadowVert;\n	vec4 shadowMoments;\n	FetchShadowMoments(var_Position.xyz, shadowVert, shadowMoments);\n	\n	// FIXME\n	#if 0 // defined(r_PCFSamples)\n	shadowMoments = PCF(var_Position.xyz, u_ShadowTexelSize * u_ShadowBlur, r_PCFSamples);\n	#endif\n	\n#if 0 \n	gl_FragColor = vec4(u_ShadowTexelSize * u_ShadowBlur * u_LightRadius, 0.0, 0.0, 1.0);\n	return;\n#endif\n	\n#if defined(r_ShowParallelShadowSplits)\n	// transform to camera space\n	vec4 Pcam = u_ViewMatrix * vec4(var_Position.xyz, 1.0);\n	float vertexDistanceToCamera = -Pcam.z;\n#if defined(r_ParallelShadowSplits_1)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_2)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0"
	");\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_3)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.z)\n	{\n		gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_4)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	e"
	"lse if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.z)\n	{\n		gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.w)\n	{\n		gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#endif\n#endif // #if defined(r_ShowParallelShadowSplits)\n#elif defined(LIGHT_PROJ)\n	vec4 shadowVert = u_ShadowMatrix * vec4(var_Position.xyz, 1.0);\n	\n	// compute incident ray\n	vec3 I = var_Position.xyz - u_GlobalLightOrigin;\n	\n	const float	SHADOW_BIAS = 0.001;\n	float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n	\n	#if defined(r_PCFSamples)\n	vec4 shadowMoments = PCF(shadowVert, u_ShadowTexelSize * u_ShadowBlur, r_PCFSamples);\n	#else\n	// no filter\n	vec4 shadowMoments = FetchShadowMoments(shadowVert.xy / shadowVert.w);\n	#endif\n	\n#if 0\n	gl_FragColor = vec4(shadowMoments.r, 0.0, 0.0, 1.0);"
	"\n	return;\n#endif	\n#else\n	// compute incident ray\n	vec3 I = var_Position.xyz - u_GlobalLightOrigin;\n	\n	// const float	SHADOW_BIAS = 0.01;\n	// float vertexDistance = length(I) / u_LightRadius - 0.01;\n	\n#if 0 \n	gl_FragColor = vec4(u_ShadowTexelSize * u_ShadowBlur * length(I), 0.0, 0.0, 1.0);\n	return;\n#endif\n	#if defined(r_PCFSamples)\n	vec4 shadowMoments = PCF(I, u_ShadowTexelSize * u_ShadowBlur * length(I), r_PCFSamples);\n	#else\n	// no extra filtering, single tap\n	vec4 shadowMoments = FetchShadowMoments(I);\n	#endif\n#endif\n#if defined(ESM)\n	{		\n		const float	SHADOW_BIAS = 0.001;\n		\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n#else\n		float vertexDistance = (length(I) / u_LightRadius) - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n		// float vertexDistance = length(I) - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n		// float vertexDistance = shadowVert.z - SHADOW_BIAS;\n		// float vertexDistance = var_LightProjection.z - SHADOW"
	"_BIAS;\n#endif\n		\n		float shadowDistance = shadowMoments.r;\n		\n		// standard shadow mapping\n		shadow = vertexDistance <= shadowDistance ? 1.0 : 0.0;\n		// shadow = -(shadowDistance - vertexDistance);\n		\n		// exponential shadow mapping\n		shadow = clamp(exp(r_EsmOverDarkeningFactor * (shadowDistance - vertexDistance)), 0.0, 1.0);\n		// shadow = clamp(exp(r_EsmOverDarkeningFactor * shadowDistance) * exp(-r_EsmOverDarkeningFactor * vertexDistance), 0.0, 1.0);\n		shadow = smoothstep(0.0, 1.0, shadow);\n		\n		#if defined(r_DebugShadowMaps)\n		#extension GL_EXT_gpu_shader4 : enable\n		gl_FragColor.r = (r_DebugShadowMaps & 1) != 0 ? shadowDistance : 0.0;\n		gl_FragColor.g = (r_DebugShadowMaps & 2) != 0 ? abs(shadowDistance - vertexDistance) : 0.0;\n		gl_FragColor.b = (r_DebugShadowMaps & 4) != 0 ? shadow : 0.0;\n		gl_FragColor.a = 1.0;\n		return;\n		#endif\n	}\n#elif defined(VSM)\n	{\n		#if defined(VSM_CLAMP)\n		// convert to [-1, 1] vector space\n		shadowMoments = 2.0 * (shadowMoments - 0.5);\n		#endif\n		\n	"
	"	const float	SHADOW_BIAS = 0.001;\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - SHADOW_BIAS;\n#else\n		float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n		// float vertexDistance = length(I) - SHADOW_BIAS;\n#endif\n		shadow = ChebyshevUpperBound(shadowMoments.rg, vertexDistance, VSM_EPSILON);\n	}\n#elif defined(EVSM)\n	{		\n		const float	SHADOW_BIAS = 0.001;\n		\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - 0.0001;\n#else\n		// float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n		float vertexDistance = length(I) - SHADOW_BIAS;\n#endif\n		\n		vec2 warpedVertexDistances = WarpDepth(vertexDistance);\n		// derivative of warping at depth\n		vec2 depthScale = VSM_EPSILON * r_EVSMExponents * warpedVertexDistances;\n		vec2 minVariance = depthScale * depthScale;\n	\n		float posContrib = ChebyshevUpperBound(shadowMoments.xz, warpedVertexDistances.x, minVariance.x);\n		float negContrib = ChebyshevUpperBound(shadowMoments.yw, warpedVertexDi"
	"stances.y, minVariance.y);\n		\n		shadow = min(posContrib, negContrib);\n		\n		#if defined(r_DebugShadowMaps)\n		#extension GL_EXT_gpu_shader4 : enable\n		gl_FragColor.r = (r_DebugShadowMaps & 1) != 0 ? posContrib : 0.0;\n		gl_FragColor.g = (r_DebugShadowMaps & 2) != 0 ? negContrib : 0.0;\n		gl_FragColor.b = (r_DebugShadowMaps & 4) != 0 ? shadow : 0.0;\n		gl_FragColor.a = 1.0;\n		return;\n		#endif\n		\n	}\n#endif\n	if(shadow <= 0.0)\n	{\n		discard;\n		return;\n	}\n#endif // USE_SHADOWING\n#if defined(USE_NORMAL_MAPPING)\n	#if defined(USE_NORMALIZATION_CUBE)\n	vec3 L = textureCube(u_NormalCubeMapImage, var_LightVector).xyz * 2 - 1;\n	vec3 H = textureCube(u_NormalCubeMapImage, var_HalfAngleVector).xyz * 2 - 1;\n	vec3 N = texture2D(u_NormalImage, var_BumpST).wyz * 2 - 1;\n	#else\n	vec3 L = normalize(var_LightVector);\n	vec3 H = normalize(var_HalfAngleVector);\n	// NOTE: this is .wyz and not .xyz !!!\n	vec3 N = normalize(2.0 * (texture2D(u_NormalImage, var_BumpST).wyz - 0.5));\n	#endif\n#else\n	vec3 L = normalize("
	"var_LightVector);\n	vec3 H = normalize(var_HalfAngleVector);\n	vec3 N = normalize(var_Normal);\n#endif\n   \n#if defined(HALF_LAMBERT)\n	// http://developer.valvesoftware.com/wiki/Half_Lambert\n	float NdotL = dot(N, L) * 0.5 + 0.5;\n	NdotL *= NdotL;\n#else\n	// traditional very dark Lambert light model used in Doom 3\n	float NdotL = clamp(dot(N, L), 0.0, 1.0);\n#endif\n	vec4 Cd = u_DiffuseColor * texture2D(u_DiffuseImage, var_DiffuseST);\n	float NdotH = clamp(dot(N, H), 0.0, 1.0);\n#if 0 //defined(DOOM3)\n	vec4 spec = u_SpecularColor * texture2D(u_SpecularTableImage, NdotH).x;\n	vec4 Cs = spec * 2 * texture2D(u_SpecularImage, var_SpecularST);\n#else\n	// Blinn–Phong shading model\n	vec4 Cs = vec4(2.0) * vec4(texture2D(u_SpecularImage, var_SpecularST).rgb * pow(NdotH, 16.0), 1.0);\n#endif\n	vec4 Cl = texture2DProj(u_LightImage, var_LightProjection) * texture2D(u_LightFalloffImage, var_LightFalloff);\n#if defined(VSM)\n	gl_FragColor = var_PrimaryColor * Cl * NdotL * (Cd + Cs) * shadow;\n#else\n	gl_FragColor = va"
	"r_PrimaryColor * Cl * NdotL * (Cd + Cs) * shadow;\n#endif\n	// gl_FragColor = Cl * NdotL * (Cd + Cs);\n	// gl_FragColor = vec4(NdotL) * shadow;\n	// gl_FragColor = vec4(shadow);\n	// gl_FragColor = Cd;\n}\n"},

{ "shadowVolume_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\n// attribute vec4		va_Color;\nuniform vec3		u_LocalLightOrigin;\n// uniform mat4		u_ModelViewProjectionMatrix;\nvarying vec4		var_Color;\nvoid	main()\n{\n	if(gl_Vertex.w == 1.0)\n	{\n		// transform vertex position into homogenous clip-space\n		gl_Position = ftransform();\n	}\n	else\n	{\n		// project vertex position to infinity\n		vec4 vertex = vec4((gl_Vertex.xyz - u_LocalLightOrigin), 0.0);\n		gl_Position	= gl_ModelViewProjectionMatrix * vertex;\n	}\n	\n	// assign color\n	var_Color = gl_Color;\n}"},

{ "shadowVolume_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nvarying vec4		var_Color;\nvoid	main()\n{\n	gl_FragColor = var_Color;\n}"},

{ "shadowMap_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nattribute vec3		va_Normal;\nattribute vec4		va_TexCoord0;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform mat4		u_ModelMatrix;\nvarying vec3		var_Position;\nvarying vec2		var_Tex;\nvarying vec4		var_Color;\nvoid	main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n	\n#if defined(LIGHT_DIRECTIONAL)\n	var_Position = gl_Position.xyz / gl_Position.w;\n#else\n	// transform position into world space\n	var_Position = (u_ModelMatrix * gl_Vertex).xyz;\n	// var_Position = gl_Position.xyz / gl_Position.w;\n#endif\n	\n	// diffuse map texgen\n	var_Tex.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_Tex.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n		\n	var_Color = gl_Color;\n}\n"},

{ "shadowMap_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform sampler2D	u_ColorImage;\n// uniform int		u_AlphaTest;\n// uniform vec4		u_PortalPlane;\nuniform vec3		u_GlobalLightOrigin;\nuniform float       u_LightRadius;\nvarying vec3		var_Position;\nvarying vec2		var_Tex;\nvarying vec4		var_Color;\n#if defined(EVSM)\nvec2 WarpDepth(float depth)\n{\n    // rescale depth into [-1, 1]\n    depth = 2.0 * depth - 1.0;\n    float pos =  exp( r_EVSMExponents.x * depth);\n    float neg = -exp(-r_EVSMExponents.y * depth);\n	\n    return vec2(pos, neg);\n}\nvec4 ShadowDepthToEVSM(float depth)\n{\n	vec2 warpedDepth = WarpDepth(depth);\n	return vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n#endif // #if defined(EVSM)\nvoid	main()\n{\n#if defined(USE_PORTAL_CLIPPING)\n	{\n		float dist = dot(var_Position.xyz, u_PortalPlane.xyz) - u_PortalPlane.w;\n		if(dist < 0.0)\n		{\n			discard;\n			return;\n		}\n	}\n#endif\n	vec4 color = texture2D(u_ColorImage, var_Tex);\n#if defined(USE_ALPHA_TESTING)\n	if(u_"
	"AlphaTest == ATEST_GT_0 && color.a <= 0.0)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_LT_128 && color.a >= 0.5)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_GE_128 && color.a < 0.5)\n	{\n		discard;\n		return;\n	}\n#endif\n	\n#if defined(VSM)\n	float distance;\n#if defined(LIGHT_DIRECTIONAL)\n	distance = gl_FragCoord.z;\n#else\n	distance = length(var_Position - u_GlobalLightOrigin) / u_LightRadius;\n	// distance = length(var_Position - u_GlobalLightOrigin);\n#endif\n	\n	float distanceSquared = distance * distance;\n	// shadowmap can be float RGBA or luminance alpha so store distanceSquared into alpha\n	\n#if defined(VSM_CLAMP)\n	// convert to [0,1] color space\n	gl_FragColor = vec4(distance, distanceSquared, 0.0 , 0.0) * 0.5 + 0.5;\n#else\n	gl_FragColor = vec4(distance, distanceSquared, 0.0, 0.0);\n#endif\n#elif defined(EVSM) || defined(ESM)\n	\n	float distance;\n#if defined(LIGHT_DIRECTIONAL)\n	{\n		distance = gl_FragCoord.z;// * r_ShadowMapDepthScale;\n		// distance /= gl_F"
	"ragCoord.w;\n		// distance = var_Position.z / var_Position.w;\n		// distance = var_Position.z;\n	}\n#else\n	{\n		distance = (length(var_Position - u_GlobalLightOrigin) / u_LightRadius); // * r_ShadowMapDepthScale;\n		// distance = length(var_Position - u_GlobalLightOrigin);\n	}\n#endif\n	\n#if defined(EVSM)\n#if !defined(r_EVSMPostProcess)\n	gl_FragColor = ShadowDepthToEVSM(distance);\n#else\n	gl_FragColor = vec4(distance, 0.0, 0.0, 0.0);\n#endif\n#else\n	gl_FragColor = vec4(distance, 0.0, 0.0, 0.0);\n#endif // defined(EVSM)\n	\n#else\n	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n#endif\n}\n"},

{ "toneMapping_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		attr_Position;\n// uniform mat4		u_ModelViewProjectionMatrix;\nvoid	main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n}\n"},

{ "toneMapping_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform sampler2D	u_CurrentRenderImage;\nuniform float		u_HDRKey;\nuniform float		u_HDRAverageLuminance;\nuniform float		u_HDRMaxLuminance;\nconst vec4			LUMINANCE_VECTOR = vec4(0.2125, 0.7154, 0.0721, 0.0);\nconst vec3			BLUE_SHIFT_VECTOR = vec3(1.05, 0.97, 1.27); \nvoid	main()\n{\n	// calculate the screen texcoord in the 0.0 to 1.0 range\n	vec2 st = gl_FragCoord.st * r_FBufScale;\n	\n#if defined(BRIGHTPASS_FILTER)\n	// multiply with 4 because the FBO is only 1/4th of the screen resolution\n	st *= vec2(4.0, 4.0);\n#endif\n	\n	// scale by the screen non-power-of-two-adjust\n	st *= r_NPOTScale;\n	\n	vec4 color = texture2D(u_CurrentRenderImage, st);\n	\n#if 1\n	// gl_FragColor = vec4(st.s, st.t, 0.0, 1.0);\n	gl_FragColor = color;\n	return;\n#endif\n	\n	// see http://www.gamedev.net/reference/articles/article2208.asp\n	// for Mathematics of Reinhard's Photographic Tone Reproduction Operator\n	\n	// get the luminance of the current pixel\n	float Y "
	"= dot(LUMINANCE_VECTOR, color);\n#if defined(BRIGHTPASS_FILTER)\n	if(Y < 0.1)\n	{\n		discard;\n		return;\n	}\n#endif\n	\n	// calculate the relative luminance\n	float Yr = u_HDRKey * Y / u_HDRAverageLuminance;\n	float Ymax = u_HDRMaxLuminance;\n	// RGB -> XYZ conversion \n	const mat3 RGB2XYZ = mat3(  0.4124564,  0.3575761,  0.1804375, \n								0.2126729,  0.7151522,  0.0721750, \n								0.0193339,  0.1191920,  0.9503041);				                      \n								\n	vec3 XYZ = RGB2XYZ * color.rgb;\n	\n	// XYZ -> Yxy conversion \n	vec3 Yxy; \n	\n	// Y = Y luminance\n	Yxy.r = XYZ.g;\n	\n	// x = X / (X + Y + Z)\n	Yxy.g = XYZ.r / (XYZ.r + XYZ.g + XYZ.b);\n	\n	// y = Y / (X + Y + Z)\n	Yxy.b = XYZ.g / (XYZ.r + XYZ.g + XYZ.b);\n	\n	// (Lp) map average luminance to the middlegrey zone by scaling pixel luminance \n	float Lp = Yxy.r * u_HDRKey / u_HDRAverageLuminance;\n	\n	// (Ld) scale all luminance within a displayable range of 0 to 1\n	\n#if 0 // defined(r_HDRToneMappingOperator_1)\n	Yxy.r = (Lp * (1.0 + Lp / (Ymax * Ymax)"
	")) / (1.0 + Lp);\n#else\n	Yxy.r = 1.0 - exp(-Lp);\n#endif\n	\n	// Yxy -> XYZ conversion \n	\n	// X = Y * x / y\n	XYZ.r = Yxy.r * Yxy.g / Yxy.b;\n	\n	// Y = Y\n	XYZ.g = Yxy.r;\n	\n	// Z = Y * (1-x-y) / y  or  Z = (1 - x - y) * (Y / y)\n	XYZ.b = (1 - Yxy.g - Yxy.b) * (Yxy.r / Yxy.b);\n	\n	// XYZ -> RGB conversion\n	const mat3 XYZ2RGB  = mat3(	3.2404542, -1.5371385, -0.4985314,\n								-0.9692660,  1.8760108,  0.0415560,\n								0.0556434, -0.2040259, 1.0572252);\n	\n	color.rgb = clamp(XYZ2RGB * XYZ, 0.0, 1.0);\n	// color.rgb *= Yxy.r;\n	\n#if defined(BRIGHTPASS_FILTER)\n#if defined(r_HDRRendering)\n	// adjust contrast\n	// L = pow(L, 1.32);\n	\n	float T = max(Lp - r_HDRContrastThreshold, 0.0);\n	// float T = max(1.0 - exp(-Yr) - r_HDRContrastThreshold, 0.0);\n	float B = T > 0.0 ? T / (r_HDRContrastOffset + T) : T;\n	\n	color.rgb *= clamp(B, 0.0, 1.0);\n#endif\n#endif\n	\n#if 0 // defined(r_HDRGamma)\n	float gamma = 1.0 / r_HDRGamma;\n	color.r = pow(color.r, gamma);\n	color.g = pow(color.g, gamma);\n	color.b = "
	"pow(color.b, gamma);\n#endif\n	\n	gl_FragColor = color;\n	\n#if 1\n	gl_FragColor = vec4(Lp, Lp, Lp, 1.0);\n#endif\n}\n"},

{0, 0},

};
