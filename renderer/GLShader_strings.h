/* OpenGL GLSL shaders, as static data buffers for release mode builds */
/* DO NOT EDIT - this file is autogenerated - see BUILD.txt */
/* To regenerate this file, run: premake4 embed */ 

typedef struct {
	char *name;
	char *shaderText;
} glslShaderDef_t;

static const glslShaderDef_t glsl_shaders[] = {
{ "forwardLighting_vs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\nattribute vec4		va_TexCoord0;\nattribute vec3		va_Tangent;\nattribute vec3		va_Bitangent;\nattribute vec3		va_Normal;\n// attribute vec4		va_Color;\nuniform vec3		u_LocalLightOrigin;\nuniform vec3		u_ViewOrigin;\nuniform vec4		u_LightProjectS;\nuniform vec4		u_LightProjectT;\nuniform vec4		u_LightProjectQ;\nuniform vec4		u_LightFalloffS;\nuniform mat4		u_ModelMatrix;\nuniform mat4		u_ShadowMatrix;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform vec4		u_BumpMatrixS;\nuniform vec4		u_BumpMatrixT;\nuniform vec4		u_SpecularMatrixS;\nuniform vec4		u_SpecularMatrixT;\nuniform vec4		u_ColorModulate;\nuniform vec4		u_Color;\n/*\n#if defined(AMBIENT_ONLY)\nuniform vec3		u_ModelMatrix0		: ENV20,\nuniform vec3		modelMatrix1		: ENV21,\nuniform vec3		modelMatrix2		: ENV22,\n#endif\n*/\nvarying vec4		var_Position;\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		v"
	"ar_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying vec3		var_LightProjection;\nvarying vec4		var_ShadowProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n	\n	// transform position into world space\n	var_Position = u_ModelMatrix * gl_Vertex;\n	// light falloff texgen\n	var_LightFalloff.x = dot(u_LightFalloffS, gl_Vertex);\n	var_LightFalloff.y = 0.5;\n  \n	// light projection texgen\n	// var_LightProjection = mat4x3(u_LightProjectS, u_LightProjectT, u_LightProjectQ) * gl_Vertex;\n#if 1\n	var_LightProjection.s = dot(u_LightProjectS, gl_Vertex);\n	var_LightProjection.t = dot(u_LightProjectT, gl_Vertex);\n	var_LightProjection.z = dot(u_LightProjectQ, gl_Vertex);\n#else\n	mat4 lightMVP = mat4(	u_LightProjectS.x, u_LightProjectT.x, u_LightFalloffS.x, u_LightProjectQ.x,\n							u_Li"
	"ghtProjectS.y, u_LightProjectT.y, u_LightFalloffS.y, u_LightProjectQ.y,\n							u_LightProjectS.z, u_LightProjectT.z, u_LightFalloffS.z, u_LightProjectQ.z,\n							u_LightProjectS.w, u_LightProjectT.w, u_LightFalloffS.w, u_LightProjectQ.w);\n							\n	var_LightProjection = (lightMVP * gl_Vertex).xyw;\n#endif\n#if defined(USE_SHADOWING)\n	var_ShadowProjection = u_ShadowMatrix * gl_Vertex;\n#endif\n	// diffuse map texgen\n	// var_DiffuseST = mat4x2(u_DiffuseMatrixS, u_DiffuseMatrixT) * va_TexCoord0;\n	var_DiffuseST.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_DiffuseST.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n	// specular map texgen\n	// var_SpecularST = mat4x2(u_SpecularMatrixS, u_SpecularMatrixT) * va_TexCoord0;\n	var_SpecularST.s = dot(u_SpecularMatrixS, va_TexCoord0);\n	var_SpecularST.t = dot(u_SpecularMatrixT, va_TexCoord0);\n	// light and halfangle vectors\n	vec3 L = normalize(u_LocalLightOrigin.xyz - gl_Vertex.xyz);\n	vec3 V = normalize(u_ViewOrigin.xyz - gl_Vertex.xyz);\n	vec3 H = normalize(L) + norma"
	"lize(V);\n	\n#if defined(USE_NORMAL_MAPPING)\n	// normal map texgen\n	// var_BumpST = mat4x2(u_BumpMatrixS, u_BumpMatrixT) * va_TexCoord0;\n	var_BumpST.s = dot(u_BumpMatrixS, va_TexCoord0);\n	var_BumpST.t = dot(u_BumpMatrixT, va_TexCoord0);\n	// rotate L and H into tangent space\n	\n	// mat3 TBN = mat3(normalize(va_Tangent), normalize(va_Bitangent), normalize(va_Normal));\n#if 0\n	mat3 TBN = transpose(mat3(va_Tangent, va_Bitangent, va_Normal));\n#else\n	mat3 TBN = mat3(va_Tangent.x, va_Bitangent.x, va_Normal.x,\n					va_Tangent.y, va_Bitangent.y, va_Normal.y,\n					va_Tangent.z, va_Bitangent.z, va_Normal.z);\n#endif\n	\n	var_LightVector = TBN * L;\n	var_HalfAngleVector = TBN * H;\n#else\n	// regular blinn-phong lighting can be done in object space\n	var_Normal = va_Normal;\n	var_LightVector = L;\n	var_HalfAngleVector = H;\n#endif\n	// primary color\n// #if defined(DOOM3)\n	var_PrimaryColor = gl_Color * u_ColorModulate + u_Color;\n// #else\n	// this was simplified in Quake 4\n// 	var_PrimaryColor = (color * u_C"
	"olorModulate.x) + u_ColorModulate.y;\n// #endif\n}\n"},

{ "forwardLighting_fs", 	"/*\nCopyright (C) 2009-2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform samplerCube u_NormalCubeMapImage;	// TEXUNIT0\nuniform sampler2D   u_NormalImage; 			// TEXUNIT1\nuniform sampler2D   u_LightFalloffImage;	// TEXUNIT2\nuniform sampler2D   u_LightImage;			// TEXUNIT3\nuniform sampler2D   u_DiffuseImage;			// TEXUNIT4\nuniform sampler2D   u_SpecularImage;		// TEXUNIT5\nuniform sampler2D   u_JitterImage;			// TEXUNIT6\n// #if defined(LIGHT_DIRECTIONAL)\nuniform sampler2D	u_ShadowImage0;\nuniform sampler2D	u_ShadowImage1;\nuniform sampler2D	u_ShadowImage2;\nuniform sampler2D	u_ShadowImage3;\nuniform sampler2D	u_ShadowImage4;\n// #elif defined(LIGHT_PROJ)\n// uniform sampler2D	u_ShadowImage0;\n// #else\nuniform samplerCube	u_ShadowCubeImage;\n// #endif\nuniform mat4		u_ModelMatrix;\nuniform mat4		u_ShadowMatrix;\nuniform float       u_ShadowTexelSize;\nuniform float       u_ShadowBlur;\nuniform vec4		u_PositionToJitterTexScale;\nuniform vec4		u_JitterTexScale;\nuniform vec4		u_JitterTexOffset;\nuniform"
	" vec4		u_DiffuseColor;\nuniform vec4		u_SpecularColor;\nuniform vec3		u_LocalLightOrigin;\nuniform vec3		u_GlobalLightOrigin;\nuniform float       u_LightRadius;\nvarying vec4		var_Position;\nvarying vec3		var_LightVector;\n#if defined(USE_NORMAL_MAPPING)\nvarying vec2		var_BumpST;\n#else\nvarying vec3		var_Normal;\n#endif\nvarying vec2		var_LightFalloff;\nvarying vec3		var_LightProjection;\nvarying vec4		var_ShadowProjection;\nvarying vec2		var_DiffuseST;\nvarying vec2		var_SpecularST;\nvarying vec3		var_HalfAngleVector;\nvarying vec4		var_PrimaryColor;\nvoid MakeNormalVectors(const vec3 forward, inout vec3 right, inout vec3 up)\n{\n	right.y = -forward.x;\n	right.z = forward.y;\n	right.x = forward.z;\n	float d = dot(right, forward);\n	right += forward * -d;\n	normalize(right);\n	up = cross(right, forward);\n}\nfloat Rand(vec2 co)\n{\n	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat Noise(vec2 co)\n{\n	return Rand(floor(co * 128.0));\n}\nvec3 RandomVec3(vec2 st)\n{\n	vec3 dir;\n#if "
	"1\n	float r = Rand(st + u_JitterTexOffset.st);\n	float angle = 2.0 * M_PI * r;// / 360.0;\n	\n	dir = normalize(vec3(cos(angle), sin(angle), r));\n#else\n	// dir = texture2D(u_NoiseMap, gl_FragCoord.st * r_FBufScale).rgb;\n	// st *= r_FBufScale.st * ; // * u_JitterTexScale.st + u_JitterTexOffset.st;\n	\n	st *= u_PositionToJitterTexScale.st * u_JitterTexScale.st;\n	st += u_JitterTexOffset.st;\n	// gl_FragColor = vec4(texture2D(u_JitterImage, st).rgb, 1.0);\n	\n	dir = normalize(2.0 * (texture2D(u_JitterImage, st).xyz - 0.5));\n#endif\n	\n	return dir;\n}\n/*\nsource: http://en.wikipedia.org/wiki/Chebyshev%27s_inequality\nX = distribution\nmu = mean\nsigma = standard deviation\n=> then for any real number k > 0:\nPr(X -mu >= k * sigma) <= 1 / ( 1 + k^2)\n*/\n#if defined(VSM) || defined(EVSM)\nfloat ChebyshevUpperBound(vec2 shadowMoments, float vertexDistance, float minVariance)\n{\n	float shadowDistance = shadowMoments.x;\n	float shadowDistanceSquared = shadowMoments.y;\n	// compute variance\n	float E_x2 = shadowDi"
	"stanceSquared;\n	float Ex_2 = shadowDistance * shadowDistance;\n	float variance = max(E_x2 - Ex_2, max(minVariance, VSM_EPSILON));\n	// float variance = smoothstep(minVariance, 1.0, max(E_x2 - Ex_2, 0.0));\n	// compute probabilistic upper bound\n	float d = vertexDistance - shadowDistance;\n	float pMax = variance / (variance + (d * d));\n	\n	/*\n	#if defined(r_LightBleedReduction)\n	pMax = smoothstep(r_LightBleedReduction, 1.0, pMax);\n	#endif\n	*/\n	\n	// one-tailed Chebyshev with k > 0\n	return (vertexDistance <= shadowDistance ? 1.0 : pMax);\n}\n#endif\n#if defined(EVSM)\nvec2 WarpDepth(float depth)\n{\n    // rescale depth into [-1, 1]\n    depth = 2.0 * depth - 1.0;\n    float pos =  exp( r_EVSMExponents.x * depth);\n    float neg = -exp(-r_EVSMExponents.y * depth);\n	\n    return vec2(pos, neg);\n}\nvec4 ShadowDepthToEVSM(float depth)\n{\n	vec2 warpedDepth = WarpDepth(depth);\n	return vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n#endif // #if defined(EVSM)\n#if defined(LIGHT_PROJ)\nvec4 Fetc"
	"hShadowMoments(vec2 st)\n{\n#if defined(EVSM) && defined(r_EVSMPostProcess)\n	return ShadowDepthToEVSM(texture2D(u_ShadowImage0, st).r);\n#else\n	// return texture2DProj(u_ShadowImage0, (u_ShadowMatrix * var_Position.xyzw).xyw);\n	return texture2DProj(u_ShadowImage0, var_LightProjection.xyz);\n	// return texture2DProj(u_ShadowImage0, var_ShadowProjection.xyz);\n	// return texture2D(u_ShadowImage0, st);\n#endif\n}\n#if defined(r_PCFSamples)\nvec4 PCF(vec4 shadowVert, float filterWidth, float samples)\n{\n	vec4 moments = vec4(0.0, 0.0, 0.0, 0.0);\n	\n#if 0\n	// compute step size for iterating through the kernel\n	float stepSize = 2.0 * filterWidth / samples;\n	for(float i = -filterWidth; i < filterWidth; i += stepSize)\n	{\n		for(float j = -filterWidth; j < filterWidth; j += stepSize)\n		{\n			moments += FetchShadowMoments(shadowVert.xy / shadowVert.w + vec2(i, j));\n		}\n	}\n#else\n	for(int i = 0; i < samples; i++)\n	{\n		for(int j = 0; j < samples; j++)\n		{\n			vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufS"
	"cale + vec2(i, j));// * filterWidth;\n			// rand = vec3(0.0, 0.0, 1.0);\n			// rand.z = 0;\n			// rand = normalize(rand);// * filterWidth;\n			\n			moments += FetchShadowMoments(shadowVert.xy / shadowVert.w + rand.xy);\n		}\n	}\n#endif\n	\n	// return average of the samples\n	moments *= (1.0 / (samples * samples));\n	return moments;\n}\n#endif // #if defined(r_PCFSamples)\n#else\nvec4 FetchShadowMoments(vec3 I)\n{\n#if defined(EVSM) && defined(r_EVSMPostProcess)\n	return ShadowDepthToEVSM(textureCube(u_ShadowCubeImage, I).r);\n#else\n	return textureCube(u_ShadowCubeImage, I);\n#endif\n}\n#if defined(r_PCFSamples)\nvec4 PCF(vec3 I, float filterWidth, float samples)\n{\n	vec3 forward, right, up;\n	\n	forward = normalize(I);\n	MakeNormalVectors(forward, right, up);\n	\n	vec4 moments = vec4(0.0, 0.0, 0.0, 0.0);\n	\n#if 0\n	// compute step size for iterating through the kernel\n	float stepSize = 2.0 * filterWidth / samples;\n	for(float i = -filterWidth; i < filterWidth; i += stepSize)\n	{\n		for(float j = -filterWid"
	"th; j < filterWidth; j += stepSize)\n		{\n			moments += FetchShadowMoments(I + right * i + up * j);\n		}\n	}\n#else\n	for(int i = 0; i < samples; i++)\n	{\n		for(int j = 0; j < samples; j++)\n		{\n			// vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufScale + vec2(i, j));// * filterWidth;\n			vec3 rand = RandomVec3(gl_FragCoord.st * r_FBufScale + vec2(i, j));// * u_ShadowTexelSize);\n			// rand.z = 0;\n			// rand = normalize(rand) * filterWidth;\n			\n			moments += FetchShadowMoments(I + right * rand.x + up * rand.y);\n		}\n	}\n#endif\n	\n	// return average of the samples\n	moments *= (1.0 / (samples * samples));\n	return moments;\n}\n#endif // #if defined(r_PCFSamples)\n#endif\nvoid main()\n{\n#if 0\n	// create random noise vector\n	vec3 rand = RandomVec3(gl_FragCoord.st);\n	gl_FragColor = vec4(rand * 0.5 + 0.5, 1.0);\n	// vec2 st = gl_FragCoord.st * u_PositionToJitterTexScale.st;// * u_JitterTexScale.st;\n	// st += u_JitterTexOffset.st;\n	// gl_FragColor = vec4(texture2D(u_JitterImage, st).rgb, 1.0);\n	return;"
	"\n#endif\n	float shadow = 1.0;\n	\n#if defined(USE_SHADOWING)\n#if defined(LIGHT_DIRECTIONAL)\n	vec4 shadowVert;\n	vec4 shadowMoments;\n	FetchShadowMoments(var_Position.xyz, shadowVert, shadowMoments);\n	\n	// FIXME\n	#if 0 // defined(r_PCFSamples)\n	shadowMoments = PCF(var_Position.xyz, u_ShadowTexelSize * u_ShadowBlur, r_PCFSamples);\n	#endif\n	\n#if 0 \n	gl_FragColor = vec4(u_ShadowTexelSize * u_ShadowBlur * u_LightRadius, 0.0, 0.0, 1.0);\n	return;\n#endif\n	\n#if defined(r_ShowParallelShadowSplits)\n	// transform to camera space\n	vec4 Pcam = u_ViewMatrix * vec4(var_Position.xyz, 1.0);\n	float vertexDistanceToCamera = -Pcam.z;\n#if defined(r_ParallelShadowSplits_1)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_2)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0"
	");\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_3)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.z)\n	{\n		gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#elif defined(r_ParallelShadowSplits_4)\n	if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.x)\n	{\n		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.y)\n	{\n		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	e"
	"lse if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.z)\n	{\n		gl_FragColor = vec4(0.0, 0.0, 1.0, 1.0);\n		return;\n	}\n	else if(vertexDistanceToCamera < u_ShadowParallelSplitDistances.w)\n	{\n		gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);\n		return;\n	}\n	else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#else\n	{\n		gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n		return;\n	}\n#endif\n#endif // #if defined(r_ShowParallelShadowSplits)\n#elif defined(LIGHT_PROJ)\n	vec4 shadowVert = u_ShadowMatrix * vec4(var_Position.xyz, 1.0);\n	\n	// compute incident ray\n	vec3 I = var_Position.xyz - u_GlobalLightOrigin;\n	\n	const float	SHADOW_BIAS = 0.001;\n	float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n	\n	#if defined(r_PCFSamples)\n	vec4 shadowMoments = PCF(shadowVert, u_ShadowTexelSize * u_ShadowBlur, r_PCFSamples);\n	#else\n	// no filter\n	vec4 shadowMoments = FetchShadowMoments(shadowVert.xy / shadowVert.w);\n	#endif\n	\n#if 0\n	gl_FragColor = shadowMoments;\n	return;\n#endif	\n#e"
	"lse\n	// compute incident ray\n	vec3 I = var_Position.xyz - u_GlobalLightOrigin;\n	\n	// const float	SHADOW_BIAS = 0.01;\n	// float vertexDistance = length(I) / u_LightRadius - 0.01;\n	\n#if 0 \n	gl_FragColor = vec4(u_ShadowTexelSize * u_ShadowBlur * length(I), 0.0, 0.0, 1.0);\n	return;\n#endif\n	#if defined(r_PCFSamples)\n	vec4 shadowMoments = PCF(I, u_ShadowTexelSize * u_ShadowBlur * length(I), r_PCFSamples);\n	#else\n	// no extra filtering, single tap\n	vec4 shadowMoments = FetchShadowMoments(I);\n	#endif\n#endif\n#if defined(ESM)\n	{		\n		const float	SHADOW_BIAS = 0.001;\n		\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n#else\n		float vertexDistance = (length(I) / u_LightRadius) - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n		// float vertexDistance = length(I) - SHADOW_BIAS; // * r_ShadowMapDepthScale;\n		// float vertexDistance = shadowVert.z - SHADOW_BIAS;\n		// float vertexDistance = var_LightProjection.z - SHADOW_BIAS;\n#endif\n		\n		f"
	"loat shadowDistance = shadowMoments.r;\n		\n		// standard shadow mapping\n		shadow = vertexDistance <= shadowDistance ? 1.0 : 0.0;\n		// shadow = -(shadowDistance - vertexDistance);\n		\n		// exponential shadow mapping\n		shadow = clamp(exp(r_EsmOverDarkeningFactor * (shadowDistance - vertexDistance)), 0.0, 1.0);\n		// shadow = clamp(exp(r_EsmOverDarkeningFactor * shadowDistance) * exp(-r_EsmOverDarkeningFactor * vertexDistance), 0.0, 1.0);\n		shadow = smoothstep(0.0, 1.0, shadow);\n		\n		#if defined(r_DebugShadowMaps)\n		#extension GL_EXT_gpu_shader4 : enable\n		gl_FragColor.r = (r_DebugShadowMaps & 1) != 0 ? shadowDistance : 0.0;\n		gl_FragColor.g = (r_DebugShadowMaps & 2) != 0 ? abs(shadowDistance - vertexDistance) : 0.0;\n		gl_FragColor.b = (r_DebugShadowMaps & 4) != 0 ? shadow : 0.0;\n		gl_FragColor.a = 1.0;\n		return;\n		#endif\n	}\n#elif defined(VSM)\n	{\n		#if defined(VSM_CLAMP)\n		// convert to [-1, 1] vector space\n		shadowMoments = 2.0 * (shadowMoments - 0.5);\n		#endif\n		\n		const float	SHADOW_BIA"
	"S = 0.001;\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - SHADOW_BIAS;\n#else\n		float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n		// float vertexDistance = length(I) - SHADOW_BIAS;\n#endif\n		shadow = ChebyshevUpperBound(shadowMoments.rg, vertexDistance, VSM_EPSILON);\n	}\n#elif defined(EVSM)\n	{		\n		const float	SHADOW_BIAS = 0.001;\n		\n#if defined(LIGHT_DIRECTIONAL)\n		float vertexDistance = shadowVert.z - 0.0001;\n#else\n		// float vertexDistance = length(I) / u_LightRadius - SHADOW_BIAS;\n		float vertexDistance = length(I) - SHADOW_BIAS;\n#endif\n		\n		vec2 warpedVertexDistances = WarpDepth(vertexDistance);\n		// derivative of warping at depth\n		vec2 depthScale = VSM_EPSILON * r_EVSMExponents * warpedVertexDistances;\n		vec2 minVariance = depthScale * depthScale;\n	\n		float posContrib = ChebyshevUpperBound(shadowMoments.xz, warpedVertexDistances.x, minVariance.x);\n		float negContrib = ChebyshevUpperBound(shadowMoments.yw, warpedVertexDistances.y, minVariance."
	"y);\n		\n		shadow = min(posContrib, negContrib);\n		\n		#if defined(r_DebugShadowMaps)\n		#extension GL_EXT_gpu_shader4 : enable\n		gl_FragColor.r = (r_DebugShadowMaps & 1) != 0 ? posContrib : 0.0;\n		gl_FragColor.g = (r_DebugShadowMaps & 2) != 0 ? negContrib : 0.0;\n		gl_FragColor.b = (r_DebugShadowMaps & 4) != 0 ? shadow : 0.0;\n		gl_FragColor.a = 1.0;\n		return;\n		#endif\n		\n	}\n#endif\n	if(shadow <= 0.0)\n	{\n		discard;\n		return;\n	}\n#endif // USE_SHADOWING\n#if defined(USE_NORMAL_MAPPING)\n	#if defined(USE_NORMALIZATION_CUBE)\n	vec3 L = textureCube(u_NormalCubeMapImage, var_LightVector).xyz * 2 - 1;\n	vec3 H = textureCube(u_NormalCubeMapImage, var_HalfAngleVector).xyz * 2 - 1;\n	vec3 N = texture2D(u_NormalImage, var_BumpST).wyz * 2 - 1;\n	#else\n	vec3 L = normalize(var_LightVector);\n	vec3 H = normalize(var_HalfAngleVector);\n	// NOTE: this is .wyz and not .xyz !!!\n	vec3 N = normalize(2.0 * (texture2D(u_NormalImage, var_BumpST).wyz - 0.5));\n	#endif\n#else\n	vec3 L = normalize(var_LightVector);\n	vec"
	"3 H = normalize(var_HalfAngleVector);\n	vec3 N = normalize(var_Normal);\n#endif\n   \n#if defined(HALF_LAMBERT)\n	// http://developer.valvesoftware.com/wiki/Half_Lambert\n	float NdotL = dot(N, L) * 0.5 + 0.5;\n	NdotL *= NdotL;\n#else\n	// traditional very dark Lambert light model used in Doom 3\n	float NdotL = clamp(dot(N, L), 0.0, 1.0);\n#endif\n	vec4 Cd = u_DiffuseColor * texture2D(u_DiffuseImage, var_DiffuseST);\n	float NdotH = clamp(dot(N, H), 0.0, 1.0);\n#if 0 //defined(DOOM3)\n	vec4 spec = u_SpecularColor * texture2D(u_SpecularTableImage, NdotH).x;\n	vec4 Cs = spec * 2 * texture2D(u_SpecularImage, var_SpecularST);\n#else\n	// Blinn–Phong shading model\n	vec4 Cs = vec4(2.0) * vec4(texture2D(u_SpecularImage, var_SpecularST).rgb * pow(NdotH, 16.0), 1.0);\n#endif\n	vec4 Cl = texture2DProj(u_LightImage, var_LightProjection) * texture2D(u_LightFalloffImage, var_LightFalloff);\n#if defined(VSM)\n	gl_FragColor = var_PrimaryColor * Cl * NdotL * (Cd + Cs) * shadow;\n#else\n	gl_FragColor = var_PrimaryColor * Cl * N"
	"dotL * (Cd + Cs) * shadow;\n#endif\n	// gl_FragColor = Cl * NdotL * (Cd + Cs);\n	// gl_FragColor = vec4(NdotL) * shadow;\n	// gl_FragColor = vec4(shadow);\n	// gl_FragColor = Cd;\n}\n"},

{ "shadowVolume_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\n// attribute vec4		va_Position;\n// attribute vec4		va_Color;\nuniform vec3		u_LocalLightOrigin;\n// uniform mat4		u_ModelViewProjectionMatrix;\nvarying vec4		var_Color;\nvoid	main()\n{\n	if(gl_Vertex.w == 1.0)\n	{\n		// transform vertex position into homogenous clip-space\n		gl_Position = ftransform();\n	}\n	else\n	{\n		// project vertex position to infinity\n		vec4 vertex = vec4((gl_Vertex.xyz - u_LocalLightOrigin), 0.0);\n		gl_Position	= gl_ModelViewProjectionMatrix * vertex;\n	}\n	\n	// assign color\n	var_Color = gl_Color;\n}"},

{ "shadowVolume_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nvarying vec4		var_Color;\nvoid	main()\n{\n	gl_FragColor = var_Color;\n}"},

{ "shadowMap_vs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nattribute vec3		va_Normal;\nattribute vec4		va_TexCoord0;\nuniform vec4		u_DiffuseMatrixS;\nuniform vec4		u_DiffuseMatrixT;\nuniform mat4		u_ModelMatrix;\nvarying vec3		var_Position;\nvarying vec2		var_Tex;\nvarying vec4		var_Color;\nvoid	main()\n{\n	// transform vertex position into homogenous clip-space\n	gl_Position = ftransform();\n	\n#if defined(LIGHT_DIRECTIONAL)\n	var_Position = gl_Position.xyz / gl_Position.w;\n#else\n	// transform position into world space\n	var_Position = (u_ModelMatrix * gl_Vertex).xyz;\n	// var_Position = gl_Position.xyz / gl_Position.w;\n#endif\n	\n	// diffuse map texgen\n	var_Tex.s = dot(u_DiffuseMatrixS, va_TexCoord0);\n	var_Tex.t = dot(u_DiffuseMatrixT, va_TexCoord0);\n		\n	var_Color = gl_Color;\n}\n"},

{ "shadowMap_fs", 	"/*\nCopyright (C) 2012 Robert Beckebans\nAll Rights Reserved.\n*/\nuniform sampler2D	u_ColorImage;\n// uniform int		u_AlphaTest;\n// uniform vec4		u_PortalPlane;\nuniform vec3		u_GlobalLightOrigin;\nuniform float       u_LightRadius;\nvarying vec3		var_Position;\nvarying vec2		var_Tex;\nvarying vec4		var_Color;\n#if defined(EVSM)\nvec2 WarpDepth(float depth)\n{\n    // rescale depth into [-1, 1]\n    depth = 2.0 * depth - 1.0;\n    float pos =  exp( r_EVSMExponents.x * depth);\n    float neg = -exp(-r_EVSMExponents.y * depth);\n	\n    return vec2(pos, neg);\n}\nvec4 ShadowDepthToEVSM(float depth)\n{\n	vec2 warpedDepth = WarpDepth(depth);\n	return vec4(warpedDepth.xy, warpedDepth.xy * warpedDepth.xy);\n}\n#endif // #if defined(EVSM)\nvoid	main()\n{\n#if defined(USE_PORTAL_CLIPPING)\n	{\n		float dist = dot(var_Position.xyz, u_PortalPlane.xyz) - u_PortalPlane.w;\n		if(dist < 0.0)\n		{\n			discard;\n			return;\n		}\n	}\n#endif\n	vec4 color = texture2D(u_ColorImage, var_Tex);\n#if defined(USE_ALPHA_TESTING)\n	if(u_"
	"AlphaTest == ATEST_GT_0 && color.a <= 0.0)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_LT_128 && color.a >= 0.5)\n	{\n		discard;\n		return;\n	}\n	else if(u_AlphaTest == ATEST_GE_128 && color.a < 0.5)\n	{\n		discard;\n		return;\n	}\n#endif\n	\n#if defined(VSM)\n	float distance;\n#if defined(LIGHT_DIRECTIONAL)\n	distance = gl_FragCoord.z;\n#else\n	distance = length(var_Position - u_GlobalLightOrigin) / u_LightRadius;\n	// distance = length(var_Position - u_GlobalLightOrigin);\n#endif\n	\n	float distanceSquared = distance * distance;\n	// shadowmap can be float RGBA or luminance alpha so store distanceSquared into alpha\n	\n#if defined(VSM_CLAMP)\n	// convert to [0,1] color space\n	gl_FragColor = vec4(distance, distanceSquared, 0.0 , 0.0) * 0.5 + 0.5;\n#else\n	gl_FragColor = vec4(distance, distanceSquared, 0.0, 0.0);\n#endif\n#elif defined(EVSM) || defined(ESM)\n	\n	float distance;\n#if defined(LIGHT_DIRECTIONAL)\n	{\n		distance = gl_FragCoord.z;// * r_ShadowMapDepthScale;\n		// distance /= gl_F"
	"ragCoord.w;\n		// distance = var_Position.z / var_Position.w;\n		// distance = var_Position.z;\n	}\n#else\n	{\n		distance = (length(var_Position - u_GlobalLightOrigin) / u_LightRadius); // * r_ShadowMapDepthScale;\n		// distance = length(var_Position - u_GlobalLightOrigin);\n	}\n#endif\n	\n#if defined(EVSM)\n#if !defined(r_EVSMPostProcess)\n	gl_FragColor = ShadowDepthToEVSM(distance);\n#else\n	gl_FragColor = vec4(distance, 0.0, 0.0, 0.0);\n#endif\n#else\n	gl_FragColor = vec4(distance, 0.0, 0.0, 0.0);\n#endif // defined(EVSM)\n	\n#else\n	gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n#endif\n}\n"},

{0, 0},

};
